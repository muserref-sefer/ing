{
  "version": 3,
  "sources": ["../../@lit-labs/router/src/routes.ts", "../../@lit-labs/router/src/router.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\n/// <reference types=\"urlpattern-polyfill\" />\n\nimport type {ReactiveController, ReactiveControllerHost} from 'lit';\n\nexport interface BaseRouteConfig {\n  name?: string | undefined;\n  render?: (params: {[key: string]: string | undefined}) => unknown;\n  enter?: (params: {\n    [key: string]: string | undefined;\n  }) => Promise<boolean> | boolean;\n}\n\n/**\n * A RouteConfig that matches against a `path` string. `path` must be a\n * [`URLPattern` compatible pathname pattern](https://developer.mozilla.org/en-US/docs/Web/API/URLPattern/pathname).\n */\nexport interface PathRouteConfig extends BaseRouteConfig {\n  path: string;\n}\n\n/**\n * A RouteConfig that matches against a given [`URLPattern`](https://developer.mozilla.org/en-US/docs/Web/API/URLPattern)\n *\n * While `URLPattern` can match against protocols, hostnames, and ports,\n * routes will only be checked for matches if they're part of the current\n * origin. This means that the pattern is limited to checking `pathname` and\n * `search`.\n */\nexport interface URLPatternRouteConfig extends BaseRouteConfig {\n  pattern: URLPattern;\n}\n\n/**\n * A description of a route, which path or pattern to match against, and a\n * render() callback used to render a match to the outlet.\n */\nexport type RouteConfig = PathRouteConfig | URLPatternRouteConfig;\n\n// A cache of URLPatterns created for PathRouteConfig.\n// Rather than converting all given RoutConfigs to URLPatternRouteConfig, this\n// lets us make `routes` mutable so users can add new PathRouteConfigs\n// dynamically.\nconst patternCache = new WeakMap<PathRouteConfig, URLPattern>();\n\nconst isPatternConfig = (route: RouteConfig): route is URLPatternRouteConfig =>\n  (route as URLPatternRouteConfig).pattern !== undefined;\n\nconst getPattern = (route: RouteConfig) => {\n  if (isPatternConfig(route)) {\n    return route.pattern;\n  }\n  let pattern = patternCache.get(route);\n  if (pattern === undefined) {\n    patternCache.set(route, (pattern = new URLPattern({pathname: route.path})));\n  }\n  return pattern;\n};\n\n/**\n * A reactive controller that performs location-based routing using a\n * configuration of URL patterns and associated render callbacks.\n */\nexport class Routes implements ReactiveController {\n  private readonly _host: ReactiveControllerHost & HTMLElement;\n\n  /*\n   * The currently installed set of routes in precedence order.\n   *\n   * This array is mutable. To dynamically add a new route you can write:\n   *\n   * ```ts\n   * this._routes.routes.push({\n   *   path: '/foo',\n   *   render: () => html`<p>Foo</p>`,\n   * });\n   * ```\n   *\n   * Mutating this property does not trigger any route transitions. If the\n   * changes may result is a different route matching for the current path, you\n   * must instigate a route update with `goto()`.\n   */\n  routes: Array<RouteConfig> = [];\n\n  /**\n   * A default fallback route which will always be matched if none of the\n   * {@link routes} match. Implicitly matches to the path \"/*\".\n   */\n  fallback?: BaseRouteConfig;\n\n  /*\n   * The current set of child Routes controllers. These are connected via\n   * the routes-connected event.\n   */\n  private readonly _childRoutes: Array<Routes> = [];\n\n  private _parentRoutes: Routes | undefined;\n\n  /*\n   * State related to the current matching route.\n   *\n   * We keep this so that consuming code can access current parameters, and so\n   * that we can propagate tail matches to child routes if they are added after\n   * navigation / matching.\n   */\n  private _currentPathname: string | undefined;\n  private _currentRoute: RouteConfig | undefined;\n  private _currentParams: {\n    [key: string]: string | undefined;\n  } = {};\n\n  /**\n   * Callback to call when this controller is disconnected.\n   *\n   * It's critical to call this immediately in hostDisconnected so that this\n   * controller instance doesn't receive a tail match meant for another route.\n   */\n  // TODO (justinfagnani): Do we need this now that we have a direct reference\n  // to the parent? We can call `this._parentRoutes.disconnect(this)`.\n  private _onDisconnect: (() => void) | undefined;\n\n  constructor(\n    host: ReactiveControllerHost & HTMLElement,\n    routes: Array<RouteConfig>,\n    options?: {fallback?: BaseRouteConfig}\n  ) {\n    (this._host = host).addController(this);\n    this.routes = [...routes];\n    this.fallback = options?.fallback;\n  }\n\n  /**\n   * Returns a URL string of the current route, including parent routes,\n   * optionally replacing the local path with `pathname`.\n   */\n  link(pathname?: string): string {\n    if (pathname?.startsWith('/')) {\n      return pathname;\n    }\n    if (pathname?.startsWith('.')) {\n      throw new Error('Not implemented');\n    }\n    pathname ??= this._currentPathname;\n    return (this._parentRoutes?.link() ?? '') + pathname;\n  }\n\n  /**\n   * Navigates this routes controller to `pathname`.\n   *\n   * This does not navigate parent routes, so it isn't (yet) a general page\n   * navigation API. It does navigate child routes if pathname matches a\n   * pattern with a tail wildcard pattern (`/*`).\n   */\n  async goto(pathname: string) {\n    // TODO (justinfagnani): handle absolute vs relative paths separately.\n    // TODO (justinfagnani): do we need to detect when goto() is called while\n    // a previous goto() call is still pending?\n\n    // TODO (justinfagnani): generalize this to handle query params and\n    // fragments. It currently only handles path names because it's easier to\n    // completely disregard the origin for now. The click handler only does\n    // an in-page navigation if the origin matches anyway.\n    let tailGroup: string | undefined;\n\n    if (this.routes.length === 0 && this.fallback === undefined) {\n      // If a routes controller has none of its own routes it acts like it has\n      // one route of `/*` so that it passes the whole pathname as a tail\n      // match.\n      tailGroup = pathname;\n      this._currentPathname = '';\n      // Simulate a tail group with the whole pathname\n      this._currentParams = {0: tailGroup};\n    } else {\n      const route = this._getRoute(pathname);\n      if (route === undefined) {\n        throw new Error(`No route found for ${pathname}`);\n      }\n      const pattern = getPattern(route);\n      const result = pattern.exec({pathname});\n      const params = result?.pathname.groups ?? {};\n      tailGroup = getTailGroup(params);\n      if (typeof route.enter === 'function') {\n        const success = await route.enter(params);\n        // If enter() returns false, cancel this navigation\n        if (success === false) {\n          return;\n        }\n      }\n      // Only update route state if the enter handler completes successfully\n      this._currentRoute = route;\n      this._currentParams = params;\n      this._currentPathname =\n        tailGroup === undefined\n          ? pathname\n          : pathname.substring(0, pathname.length - tailGroup.length);\n    }\n\n    // Propagate the tail match to children\n    if (tailGroup !== undefined) {\n      for (const childRoutes of this._childRoutes) {\n        childRoutes.goto(tailGroup);\n      }\n    }\n    this._host.requestUpdate();\n  }\n\n  /**\n   * The result of calling the current route's render() callback.\n   */\n  outlet() {\n    return this._currentRoute?.render?.(this._currentParams);\n  }\n\n  /**\n   * The current parsed route parameters.\n   */\n  get params() {\n    return this._currentParams;\n  }\n\n  /**\n   * Matches `url` against the installed routes and returns the first match.\n   */\n  private _getRoute(pathname: string): RouteConfig | undefined {\n    const matchedRoute = this.routes.find((r) =>\n      getPattern(r).test({pathname: pathname})\n    );\n    if (matchedRoute || this.fallback === undefined) {\n      return matchedRoute;\n    }\n    if (this.fallback) {\n      // The fallback route behaves like it has a \"/*\" path. This is hidden from\n      // the public API but is added here to return a valid RouteConfig.\n      return {...this.fallback, path: '/*'};\n    }\n    return undefined;\n  }\n\n  hostConnected() {\n    this._host.addEventListener(\n      RoutesConnectedEvent.eventName,\n      this._onRoutesConnected\n    );\n    const event = new RoutesConnectedEvent(this);\n    this._host.dispatchEvent(event);\n    this._onDisconnect = event.onDisconnect;\n  }\n\n  hostDisconnected() {\n    // When this child routes controller is disconnected because a parent\n    // outlet rendered a different template, disconnecting will ensure that\n    // this controller doesn't receive a tail match meant for another route.\n    this._onDisconnect?.();\n    this._parentRoutes = undefined;\n  }\n\n  private _onRoutesConnected = (e: RoutesConnectedEvent) => {\n    // Don't handle the event fired by this routes controller, which we get\n    // because we do this.dispatchEvent(...)\n    if (e.routes === this) {\n      return;\n    }\n\n    const childRoutes = e.routes;\n    this._childRoutes.push(childRoutes);\n    childRoutes._parentRoutes = this;\n\n    e.stopImmediatePropagation();\n    e.onDisconnect = () => {\n      // Remove route from this._childRoutes:\n      // `>>> 0` converts -1 to 2**32-1\n      this._childRoutes?.splice(\n        this._childRoutes.indexOf(childRoutes) >>> 0,\n        1\n      );\n    };\n\n    const tailGroup = getTailGroup(this._currentParams);\n    if (tailGroup !== undefined) {\n      childRoutes.goto(tailGroup);\n    }\n  };\n}\n\n/**\n * Returns the tail of a pathname groups object. This is the match from a\n * wildcard at the end of a pathname pattern, like `/foo/*`\n */\nconst getTailGroup = (groups: {[key: string]: string | undefined}) => {\n  let tailKey: string | undefined;\n  for (const key of Object.keys(groups)) {\n    if (/\\d+/.test(key) && (tailKey === undefined || key > tailKey!)) {\n      tailKey = key;\n    }\n  }\n  return tailKey && groups[tailKey];\n};\n\n/**\n * This event is fired from Routes controllers when their host is connected to\n * announce the child route and potentially connect to a parent routes controller.\n */\nexport class RoutesConnectedEvent extends Event {\n  static readonly eventName = 'lit-routes-connected';\n  readonly routes: Routes;\n  onDisconnect?: () => void;\n\n  constructor(routes: Routes) {\n    super(RoutesConnectedEvent.eventName, {\n      bubbles: true,\n      composed: true,\n      cancelable: false,\n    });\n    this.routes = routes;\n  }\n}\n\ndeclare global {\n  interface HTMLElementEventMap {\n    [RoutesConnectedEvent.eventName]: RoutesConnectedEvent;\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {Routes} from './routes.js';\n\n// We cache the origin since it can't change\nconst origin = location.origin || location.protocol + '//' + location.host;\n\n/**\n * A root-level router that installs global event listeners to intercept\n * navigation.\n *\n * This class extends Routes so that it can also have a route configuration.\n *\n * There should only be one Router instance on a page, since the Router\n * installs global event listeners on `window` and `document`. Nested\n * routes should be configured with the `Routes` class.\n */\nexport class Router extends Routes {\n  override hostConnected() {\n    super.hostConnected();\n    window.addEventListener('click', this._onClick);\n    window.addEventListener('popstate', this._onPopState);\n    // Kick off routed rendering by going to the current URL\n    this.goto(window.location.pathname);\n  }\n\n  override hostDisconnected() {\n    super.hostDisconnected();\n    window.removeEventListener('click', this._onClick);\n    window.removeEventListener('popstate', this._onPopState);\n  }\n\n  private _onClick = (e: MouseEvent) => {\n    const isNonNavigationClick =\n      e.button !== 0 || e.metaKey || e.ctrlKey || e.shiftKey;\n    if (e.defaultPrevented || isNonNavigationClick) {\n      return;\n    }\n\n    const anchor = e\n      .composedPath()\n      .find((n) => (n as HTMLElement).tagName === 'A') as\n      | HTMLAnchorElement\n      | undefined;\n    if (\n      anchor === undefined ||\n      anchor.target !== '' ||\n      anchor.hasAttribute('download') ||\n      anchor.getAttribute('rel') === 'external'\n    ) {\n      return;\n    }\n\n    const href = anchor.href;\n    if (href === '' || href.startsWith('mailto:')) {\n      return;\n    }\n\n    const location = window.location;\n    if (anchor.origin !== origin) {\n      return;\n    }\n\n    e.preventDefault();\n    if (href !== location.href) {\n      window.history.pushState({}, '', href);\n      this.goto(anchor.pathname);\n    }\n  };\n\n  private _onPopState = (_e: PopStateEvent) => {\n    this.goto(window.location.pathname);\n  };\n}\n"],
  "mappings": ";;;AAgDA,IAAM,eAAe,oBAAI,QAAO;AAEhC,IAAM,kBAAkB,CAAC,UACtB,MAAgC,YAAY;AAE/C,IAAM,aAAa,CAAC,UAAsB;AACxC,MAAI,gBAAgB,KAAK,GAAG;AAC1B,WAAO,MAAM;;AAEf,MAAI,UAAU,aAAa,IAAI,KAAK;AACpC,MAAI,YAAY,QAAW;AACzB,iBAAa,IAAI,OAAQ,UAAU,IAAI,WAAW,EAAC,UAAU,MAAM,KAAI,CAAC,CAAE;;AAE5E,SAAO;AACT;AAMM,IAAO,SAAP,MAAa;EA0DjB,YACE,MACA,QACA,SAAsC;AA1CxC,SAAA,SAA6B,CAAA;AAYZ,SAAA,eAA8B,CAAA;AAavC,SAAA,iBAEJ,CAAA;AAmJI,SAAA,qBAAqB,CAAC,MAA2B;AAGvD,UAAI,EAAE,WAAW,MAAM;AACrB;;AAGF,YAAM,cAAc,EAAE;AACtB,WAAK,aAAa,KAAK,WAAW;AAClC,kBAAY,gBAAgB;AAE5B,QAAE,yBAAwB;AAC1B,QAAE,eAAe,MAAK;AAjR1B;AAoRM,mBAAK,iBAAL,mBAAmB,OACjB,KAAK,aAAa,QAAQ,WAAW,MAAM,GAC3C;MAEJ;AAEA,YAAM,YAAY,aAAa,KAAK,cAAc;AAClD,UAAI,cAAc,QAAW;AAC3B,oBAAY,KAAK,SAAS;;IAE9B;AA3JE,KAAC,KAAK,QAAQ,MAAM,cAAc,IAAI;AACtC,SAAK,SAAS,CAAC,GAAG,MAAM;AACxB,SAAK,WAAW,mCAAS;EAC3B;;;;;EAMA,KAAK,UAAiB;AA5IxB;AA6II,QAAI,qCAAU,WAAW,MAAM;AAC7B,aAAO;;AAET,QAAI,qCAAU,WAAW,MAAM;AAC7B,YAAM,IAAI,MAAM,iBAAiB;;AAEnC,4BAAa,KAAK;AAClB,cAAQ,UAAK,kBAAL,mBAAoB,WAAU,MAAM;EAC9C;;;;;;;;EASA,MAAM,KAAK,UAAgB;AASzB,QAAI;AAEJ,QAAI,KAAK,OAAO,WAAW,KAAK,KAAK,aAAa,QAAW;AAI3D,kBAAY;AACZ,WAAK,mBAAmB;AAExB,WAAK,iBAAiB,EAAC,GAAG,UAAS;WAC9B;AACL,YAAM,QAAQ,KAAK,UAAU,QAAQ;AACrC,UAAI,UAAU,QAAW;AACvB,cAAM,IAAI,MAAM,sBAAsB,QAAQ,EAAE;;AAElD,YAAM,UAAU,WAAW,KAAK;AAChC,YAAM,SAAS,QAAQ,KAAK,EAAC,SAAQ,CAAC;AACtC,YAAM,UAAS,iCAAQ,SAAS,WAAU,CAAA;AAC1C,kBAAY,aAAa,MAAM;AAC/B,UAAI,OAAO,MAAM,UAAU,YAAY;AACrC,cAAM,UAAU,MAAM,MAAM,MAAM,MAAM;AAExC,YAAI,YAAY,OAAO;AACrB;;;AAIJ,WAAK,gBAAgB;AACrB,WAAK,iBAAiB;AACtB,WAAK,mBACH,cAAc,SACV,WACA,SAAS,UAAU,GAAG,SAAS,SAAS,UAAU,MAAM;;AAIhE,QAAI,cAAc,QAAW;AAC3B,iBAAW,eAAe,KAAK,cAAc;AAC3C,oBAAY,KAAK,SAAS;;;AAG9B,SAAK,MAAM,cAAa;EAC1B;;;;EAKA,SAAM;AAtNR;AAuNI,YAAO,gBAAK,kBAAL,mBAAoB,WAApB,4BAA6B,KAAK;EAC3C;;;;EAKA,IAAI,SAAM;AACR,WAAO,KAAK;EACd;;;;EAKQ,UAAU,UAAgB;AAChC,UAAM,eAAe,KAAK,OAAO,KAAK,CAAC,MACrC,WAAW,CAAC,EAAE,KAAK,EAAC,SAAkB,CAAC,CAAC;AAE1C,QAAI,gBAAgB,KAAK,aAAa,QAAW;AAC/C,aAAO;;AAET,QAAI,KAAK,UAAU;AAGjB,aAAO,EAAC,GAAG,KAAK,UAAU,MAAM,KAAI;;AAEtC,WAAO;EACT;EAEA,gBAAa;AACX,SAAK,MAAM,iBACT,qBAAqB,WACrB,KAAK,kBAAkB;AAEzB,UAAM,QAAQ,IAAI,qBAAqB,IAAI;AAC3C,SAAK,MAAM,cAAc,KAAK;AAC9B,SAAK,gBAAgB,MAAM;EAC7B;EAEA,mBAAgB;AA7PlB;AAiQI,eAAK,kBAAL;AACA,SAAK,gBAAgB;EACvB;;AAkCF,IAAM,eAAe,CAAC,WAA+C;AACnE,MAAI;AACJ,aAAW,OAAO,OAAO,KAAK,MAAM,GAAG;AACrC,QAAI,MAAM,KAAK,GAAG,MAAM,YAAY,UAAa,MAAM,UAAW;AAChE,gBAAU;;;AAGd,SAAO,WAAW,OAAO,OAAO;AAClC;AAMM,IAAO,uBAAP,MAAO,8BAA6B,MAAK;EAK7C,YAAY,QAAc;AACxB,UAAM,sBAAqB,WAAW;MACpC,SAAS;MACT,UAAU;MACV,YAAY;KACb;AACD,SAAK,SAAS;EAChB;;AAXgB,qBAAA,YAAY;;;AC3S9B,IAAM,SAAS,SAAS,UAAU,SAAS,WAAW,OAAO,SAAS;AAYhE,IAAO,SAAP,cAAsB,OAAM;EAAlC,cAAA;;AAeU,SAAA,WAAW,CAAC,MAAiB;AACnC,YAAM,uBACJ,EAAE,WAAW,KAAK,EAAE,WAAW,EAAE,WAAW,EAAE;AAChD,UAAI,EAAE,oBAAoB,sBAAsB;AAC9C;;AAGF,YAAM,SAAS,EACZ,aAAY,EACZ,KAAK,CAAC,MAAO,EAAkB,YAAY,GAAG;AAGjD,UACE,WAAW,UACX,OAAO,WAAW,MAClB,OAAO,aAAa,UAAU,KAC9B,OAAO,aAAa,KAAK,MAAM,YAC/B;AACA;;AAGF,YAAM,OAAO,OAAO;AACpB,UAAI,SAAS,MAAM,KAAK,WAAW,SAAS,GAAG;AAC7C;;AAGF,YAAMA,YAAW,OAAO;AACxB,UAAI,OAAO,WAAW,QAAQ;AAC5B;;AAGF,QAAE,eAAc;AAChB,UAAI,SAASA,UAAS,MAAM;AAC1B,eAAO,QAAQ,UAAU,CAAA,GAAI,IAAI,IAAI;AACrC,aAAK,KAAK,OAAO,QAAQ;;IAE7B;AAEQ,SAAA,cAAc,CAAC,OAAqB;AAC1C,WAAK,KAAK,OAAO,SAAS,QAAQ;IACpC;EACF;EAvDW,gBAAa;AACpB,UAAM,cAAa;AACnB,WAAO,iBAAiB,SAAS,KAAK,QAAQ;AAC9C,WAAO,iBAAiB,YAAY,KAAK,WAAW;AAEpD,SAAK,KAAK,OAAO,SAAS,QAAQ;EACpC;EAES,mBAAgB;AACvB,UAAM,iBAAgB;AACtB,WAAO,oBAAoB,SAAS,KAAK,QAAQ;AACjD,WAAO,oBAAoB,YAAY,KAAK,WAAW;EACzD;;",
  "names": ["location"]
}
